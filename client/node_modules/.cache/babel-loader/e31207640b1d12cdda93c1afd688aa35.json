{"ast":null,"code":"'use strict';\n\nvar _toConsumableArray = require(\"/home/faraz/courses/SE/myapp/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nvar _classCallCheck = require(\"/home/faraz/courses/SE/myapp/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/home/faraz/courses/SE/myapp/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.default = void 0;\n\nvar _cleanupSemantic = require('./cleanupSemantic');\n\nvar _printDiffs = require('./printDiffs');\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n} // Encapsulate change lines until either a common newline or the end.\n\n\nvar ChangeBuffer = /*#__PURE__*/function () {\n  // incomplete line\n  // complete lines\n  function ChangeBuffer(op) {\n    _classCallCheck(this, ChangeBuffer);\n\n    _defineProperty(this, 'op', void 0);\n\n    _defineProperty(this, 'line', void 0);\n\n    _defineProperty(this, 'lines', void 0);\n\n    this.op = op;\n    this.line = [];\n    this.lines = [];\n  }\n\n  _createClass(ChangeBuffer, [{\n    key: \"pushSubstring\",\n    value: function pushSubstring(substring) {\n      this.pushDiff(new _cleanupSemantic.Diff(this.op, substring));\n    }\n  }, {\n    key: \"pushLine\",\n    value: function pushLine() {\n      // Assume call only if line has at least one diff,\n      // therefore an empty line must have a diff which has an empty string.\n      this.lines.push(new _cleanupSemantic.Diff(this.op, (0, _printDiffs.getHighlightedString)(this.op, this.line)));\n      this.line.length = 0;\n    }\n  }, {\n    key: \"isLineEmpty\",\n    value: function isLineEmpty() {\n      return this.line.length === 0;\n    } // Minor input to buffer.\n\n  }, {\n    key: \"pushDiff\",\n    value: function pushDiff(diff) {\n      this.line.push(diff);\n    } // Main input to buffer.\n\n  }, {\n    key: \"align\",\n    value: function align(diff) {\n      var _this = this;\n\n      var string = diff[1];\n\n      if (_printDiffs.MULTILINE_REGEXP.test(string)) {\n        var substrings = string.split('\\n');\n        var iLast = substrings.length - 1;\n        substrings.forEach(function (substring, i) {\n          if (i < iLast) {\n            // The first substring completes the current change line.\n            // A middle substring is a change line.\n            _this.pushSubstring(substring);\n\n            _this.pushLine();\n          } else if (substring.length !== 0) {\n            // The last substring starts a change line, if it is not empty.\n            // Important: This non-empty condition also automatically omits\n            // the newline appended to the end of expected and received strings.\n            _this.pushSubstring(substring);\n          }\n        });\n      } else {\n        // Append non-multiline string to current change line.\n        this.pushDiff(diff);\n      }\n    } // Output from buffer.\n\n  }, {\n    key: \"moveLinesTo\",\n    value: function moveLinesTo(lines) {\n      if (!this.isLineEmpty()) {\n        this.pushLine();\n      }\n\n      lines.push.apply(lines, _toConsumableArray(this.lines));\n      this.lines.length = 0;\n    }\n  }]);\n\n  return ChangeBuffer;\n}(); // Encapsulate common and change lines.\n\n\nvar CommonBuffer = /*#__PURE__*/function () {\n  function CommonBuffer(deleteBuffer, insertBuffer) {\n    _classCallCheck(this, CommonBuffer);\n\n    _defineProperty(this, 'deleteBuffer', void 0);\n\n    _defineProperty(this, 'insertBuffer', void 0);\n\n    _defineProperty(this, 'lines', void 0);\n\n    this.deleteBuffer = deleteBuffer;\n    this.insertBuffer = insertBuffer;\n    this.lines = [];\n  }\n\n  _createClass(CommonBuffer, [{\n    key: \"pushDiffCommonLine\",\n    value: function pushDiffCommonLine(diff) {\n      this.lines.push(diff);\n    }\n  }, {\n    key: \"pushDiffChangeLines\",\n    value: function pushDiffChangeLines(diff) {\n      var isDiffEmpty = diff[1].length === 0; // An empty diff string is redundant, unless a change line is empty.\n\n      if (!isDiffEmpty || this.deleteBuffer.isLineEmpty()) {\n        this.deleteBuffer.pushDiff(diff);\n      }\n\n      if (!isDiffEmpty || this.insertBuffer.isLineEmpty()) {\n        this.insertBuffer.pushDiff(diff);\n      }\n    }\n  }, {\n    key: \"flushChangeLines\",\n    value: function flushChangeLines() {\n      this.deleteBuffer.moveLinesTo(this.lines);\n      this.insertBuffer.moveLinesTo(this.lines);\n    } // Input to buffer.\n\n  }, {\n    key: \"align\",\n    value: function align(diff) {\n      var _this2 = this;\n\n      var op = diff[0];\n      var string = diff[1];\n\n      if (_printDiffs.MULTILINE_REGEXP.test(string)) {\n        var substrings = string.split('\\n');\n        var iLast = substrings.length - 1;\n        substrings.forEach(function (substring, i) {\n          if (i === 0) {\n            var subdiff = new _cleanupSemantic.Diff(op, substring);\n\n            if (_this2.deleteBuffer.isLineEmpty() && _this2.insertBuffer.isLineEmpty()) {\n              // If both current change lines are empty,\n              // then the first substring is a common line.\n              _this2.flushChangeLines();\n\n              _this2.pushDiffCommonLine(subdiff);\n            } else {\n              // If either current change line is non-empty,\n              // then the first substring completes the change lines.\n              _this2.pushDiffChangeLines(subdiff);\n\n              _this2.flushChangeLines();\n            }\n          } else if (i < iLast) {\n            // A middle substring is a common line.\n            _this2.pushDiffCommonLine(new _cleanupSemantic.Diff(op, substring));\n          } else if (substring.length !== 0) {\n            // The last substring starts a change line, if it is not empty.\n            // Important: This non-empty condition also automatically omits\n            // the newline appended to the end of expected and received strings.\n            _this2.pushDiffChangeLines(new _cleanupSemantic.Diff(op, substring));\n          }\n        });\n      } else {\n        // Append non-multiline string to current change lines.\n        // Important: It cannot be at the end following empty change lines,\n        // because newline appended to the end of expected and received strings.\n        this.pushDiffChangeLines(diff);\n      }\n    } // Output from buffer.\n\n  }, {\n    key: \"getLines\",\n    value: function getLines() {\n      this.flushChangeLines();\n      return this.lines;\n    }\n  }]);\n\n  return CommonBuffer;\n}(); // Given diffs from expected and received strings,\n// return new array of diffs split or joined into lines.\n//\n// To correctly align a change line at the end, the algorithm:\n// * assumes that a newline was appended to the strings\n// * omits the last newline from the output array\n//\n// Assume the function is not called:\n// * if either expected or received is empty string\n// * if neither expected nor received is multiline string\n\n\nvar getAlignedDiffs = function getAlignedDiffs(diffs) {\n  var deleteBuffer = new ChangeBuffer(_cleanupSemantic.DIFF_DELETE);\n  var insertBuffer = new ChangeBuffer(_cleanupSemantic.DIFF_INSERT);\n  var commonBuffer = new CommonBuffer(deleteBuffer, insertBuffer);\n  diffs.forEach(function (diff) {\n    switch (diff[0]) {\n      case _cleanupSemantic.DIFF_DELETE:\n        deleteBuffer.align(diff);\n        break;\n\n      case _cleanupSemantic.DIFF_INSERT:\n        insertBuffer.align(diff);\n        break;\n\n      default:\n        commonBuffer.align(diff);\n    }\n  });\n  return commonBuffer.getLines();\n};\n\nvar _default = getAlignedDiffs;\nexports.default = _default;","map":{"version":3,"sources":["/home/faraz/courses/SE/myapp/client/node_modules/jest-diff/build/getAlignedDiffs.js"],"names":["Object","defineProperty","exports","value","default","_cleanupSemantic","require","_printDiffs","_defineProperty","obj","key","enumerable","configurable","writable","ChangeBuffer","op","line","lines","substring","pushDiff","Diff","push","getHighlightedString","length","diff","string","MULTILINE_REGEXP","test","substrings","split","iLast","forEach","i","pushSubstring","pushLine","isLineEmpty","CommonBuffer","deleteBuffer","insertBuffer","isDiffEmpty","moveLinesTo","subdiff","flushChangeLines","pushDiffCommonLine","pushDiffChangeLines","getAlignedDiffs","diffs","DIFF_DELETE","DIFF_INSERT","commonBuffer","align","getLines","_default"],"mappings":"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","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports.default = void 0;\n\nvar _cleanupSemantic = require('./cleanupSemantic');\n\nvar _printDiffs = require('./printDiffs');\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\n\n// Encapsulate change lines until either a common newline or the end.\nclass ChangeBuffer {\n  // incomplete line\n  // complete lines\n  constructor(op) {\n    _defineProperty(this, 'op', void 0);\n\n    _defineProperty(this, 'line', void 0);\n\n    _defineProperty(this, 'lines', void 0);\n\n    this.op = op;\n    this.line = [];\n    this.lines = [];\n  }\n\n  pushSubstring(substring) {\n    this.pushDiff(new _cleanupSemantic.Diff(this.op, substring));\n  }\n\n  pushLine() {\n    // Assume call only if line has at least one diff,\n    // therefore an empty line must have a diff which has an empty string.\n    this.lines.push(\n      new _cleanupSemantic.Diff(\n        this.op,\n        (0, _printDiffs.getHighlightedString)(this.op, this.line)\n      )\n    );\n    this.line.length = 0;\n  }\n\n  isLineEmpty() {\n    return this.line.length === 0;\n  } // Minor input to buffer.\n\n  pushDiff(diff) {\n    this.line.push(diff);\n  } // Main input to buffer.\n\n  align(diff) {\n    const string = diff[1];\n\n    if (_printDiffs.MULTILINE_REGEXP.test(string)) {\n      const substrings = string.split('\\n');\n      const iLast = substrings.length - 1;\n      substrings.forEach((substring, i) => {\n        if (i < iLast) {\n          // The first substring completes the current change line.\n          // A middle substring is a change line.\n          this.pushSubstring(substring);\n          this.pushLine();\n        } else if (substring.length !== 0) {\n          // The last substring starts a change line, if it is not empty.\n          // Important: This non-empty condition also automatically omits\n          // the newline appended to the end of expected and received strings.\n          this.pushSubstring(substring);\n        }\n      });\n    } else {\n      // Append non-multiline string to current change line.\n      this.pushDiff(diff);\n    }\n  } // Output from buffer.\n\n  moveLinesTo(lines) {\n    if (!this.isLineEmpty()) {\n      this.pushLine();\n    }\n\n    lines.push(...this.lines);\n    this.lines.length = 0;\n  }\n} // Encapsulate common and change lines.\n\nclass CommonBuffer {\n  constructor(deleteBuffer, insertBuffer) {\n    _defineProperty(this, 'deleteBuffer', void 0);\n\n    _defineProperty(this, 'insertBuffer', void 0);\n\n    _defineProperty(this, 'lines', void 0);\n\n    this.deleteBuffer = deleteBuffer;\n    this.insertBuffer = insertBuffer;\n    this.lines = [];\n  }\n\n  pushDiffCommonLine(diff) {\n    this.lines.push(diff);\n  }\n\n  pushDiffChangeLines(diff) {\n    const isDiffEmpty = diff[1].length === 0; // An empty diff string is redundant, unless a change line is empty.\n\n    if (!isDiffEmpty || this.deleteBuffer.isLineEmpty()) {\n      this.deleteBuffer.pushDiff(diff);\n    }\n\n    if (!isDiffEmpty || this.insertBuffer.isLineEmpty()) {\n      this.insertBuffer.pushDiff(diff);\n    }\n  }\n\n  flushChangeLines() {\n    this.deleteBuffer.moveLinesTo(this.lines);\n    this.insertBuffer.moveLinesTo(this.lines);\n  } // Input to buffer.\n\n  align(diff) {\n    const op = diff[0];\n    const string = diff[1];\n\n    if (_printDiffs.MULTILINE_REGEXP.test(string)) {\n      const substrings = string.split('\\n');\n      const iLast = substrings.length - 1;\n      substrings.forEach((substring, i) => {\n        if (i === 0) {\n          const subdiff = new _cleanupSemantic.Diff(op, substring);\n\n          if (\n            this.deleteBuffer.isLineEmpty() &&\n            this.insertBuffer.isLineEmpty()\n          ) {\n            // If both current change lines are empty,\n            // then the first substring is a common line.\n            this.flushChangeLines();\n            this.pushDiffCommonLine(subdiff);\n          } else {\n            // If either current change line is non-empty,\n            // then the first substring completes the change lines.\n            this.pushDiffChangeLines(subdiff);\n            this.flushChangeLines();\n          }\n        } else if (i < iLast) {\n          // A middle substring is a common line.\n          this.pushDiffCommonLine(new _cleanupSemantic.Diff(op, substring));\n        } else if (substring.length !== 0) {\n          // The last substring starts a change line, if it is not empty.\n          // Important: This non-empty condition also automatically omits\n          // the newline appended to the end of expected and received strings.\n          this.pushDiffChangeLines(new _cleanupSemantic.Diff(op, substring));\n        }\n      });\n    } else {\n      // Append non-multiline string to current change lines.\n      // Important: It cannot be at the end following empty change lines,\n      // because newline appended to the end of expected and received strings.\n      this.pushDiffChangeLines(diff);\n    }\n  } // Output from buffer.\n\n  getLines() {\n    this.flushChangeLines();\n    return this.lines;\n  }\n} // Given diffs from expected and received strings,\n// return new array of diffs split or joined into lines.\n//\n// To correctly align a change line at the end, the algorithm:\n// * assumes that a newline was appended to the strings\n// * omits the last newline from the output array\n//\n// Assume the function is not called:\n// * if either expected or received is empty string\n// * if neither expected nor received is multiline string\n\nconst getAlignedDiffs = diffs => {\n  const deleteBuffer = new ChangeBuffer(_cleanupSemantic.DIFF_DELETE);\n  const insertBuffer = new ChangeBuffer(_cleanupSemantic.DIFF_INSERT);\n  const commonBuffer = new CommonBuffer(deleteBuffer, insertBuffer);\n  diffs.forEach(diff => {\n    switch (diff[0]) {\n      case _cleanupSemantic.DIFF_DELETE:\n        deleteBuffer.align(diff);\n        break;\n\n      case _cleanupSemantic.DIFF_INSERT:\n        insertBuffer.align(diff);\n        break;\n\n      default:\n        commonBuffer.align(diff);\n    }\n  });\n  return commonBuffer.getLines();\n};\n\nvar _default = getAlignedDiffs;\nexports.default = _default;\n"]},"metadata":{},"sourceType":"script"}